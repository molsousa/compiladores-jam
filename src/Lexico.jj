options
{
  static = false;
}

PARSER_BEGIN(Lexico)

import java.util.Scanner;
import java.util.LinkedList;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

class InfoToken {
    String tipo;
    String lexema;
    int linha;
    int coluna;

    public InfoToken(String tipo, String lexema, int linha, int coluna) {
        this.tipo = tipo;
        this.lexema = lexema;
        this.linha = linha;
        this.coluna = coluna;
    }

    @Override
    public String toString() {
        return String.format("Tipo: %s\nLexema: <'%s'>\nLinha: %d, Coluna: %d\n", this.tipo, this.lexema, this.linha, this.coluna);
    }
}

public class Lexico
{
    public static LinkedList<InfoToken> reservada = new LinkedList<>();
    public static LinkedList<InfoToken> simbolo = new LinkedList<>();
    private static final int MAX = 32;

    public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException {
        Lexico parser;
        FileInputStream arquivo;
        Scanner scanner = new Scanner(System.in);

        try {
            arquivo = new FileInputStream("fonte_1.txt");
        }
        catch(FileNotFoundException e) {
            System.out.println(e);
            return;
        }

        try {
            parser = new Lexico(arquivo);
            parser.inicializar_programa();
		}
		catch(ParseException e) {
            System.out.println("Erro de sintaxe: " + e.getMessage());
        }
        catch(TokenMgrError e) {
            System.out.println("Erro léxico: " + e.getMessage());
        }
        scanner.close();
    }

    public void inserirTokenUnico(LinkedList<InfoToken> l, String tipo, Token t) {
        for (InfoToken tok : l) {
            if (tok.lexema.equals(t.image)) {
                return;
            }
        }
        l.add(new InfoToken(tipo, t.image, t.beginLine, t.beginColumn));
    }

    public void imprimirTokens(LinkedList<InfoToken> l) {
        if (l.isEmpty()) {
            System.out.println("Lista vazia");
            return;
        }
        for (InfoToken tok : l) {
            System.out.println(tok);
        }
    }
}

PARSER_END(Lexico)

// TOKENS (Léxico)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// Palavras reservadas
TOKEN:
{
    < TOKEN_IF: "if" >
|   < TOKEN_ELSE: "else" >
|   < TOKEN_WHILE: "while" >
|   < TOKEN_FOR: "for" >
|   < TOKEN_VOID: "void" >
|   < TOKEN_INT: "integer" >
|   < TOKEN_FLOAT: "float" >
|   < TOKEN_CHAR: "character" >
|   < TOKEN_BOOL: "boolean" >
|   < TOKEN_RETURN: "return" >
|   < TOKEN_TRUE: "true" >
|   < TOKEN_FALSE: "false" >
|   < TOKEN_DOUBLE: "double" >
|   < TOKEN_SWITCH: "switch" >
|   < TOKEN_DO: "do" >
|   < TOKEN_TRY: "try" >
|   < TOKEN_EXCEPT: "except" >
|   < TOKEN_IMPORT: "import" >
| 	< TOKEN_READ: "read" >
| 	< TOKEN_WRITE: "write" >
}

// Operadores
TOKEN:
{
    < ADICAO : "+" >
|   < SUBTRACAO : "-" >
|   < MULTIPLICACAO : "*" >
|   < DIVISAO : "/" >
|   < ATRIBUICAO: "=" >
|   < MODULO: "%" >
|   < IGUAL: "==" >
|   < DIFERENTE: "!=" >
|   < MENOR: "<" >
|   < MAIOR: ">" >
|   < MAIOR_IGUAL: ">=" >
|   < MENOR_IGUAL: "<=" >
|   < AND: "&&" >
|   < NOT: "!" >
|   < OR: "||" >
|   < INCREMENTO: "++" >
|   < DECREMENTO: "--" >
|   < SOMA_ATRIBUICAO: "+=" >
|   < SUBTRACAO_ATRIBUICAO: "-=" >
|   < MULTIPLICACAO_ATRIBUICAO: "*=" >
|   < DIVISAO_ATRIBUICAO: "/=" >
|   < MODULO_ATRIBUICAO: "%/" >
}

// Simbolos reservados
TOKEN:
{
    < PONTO_VIRGULA: ";" >
|   < VIRGULA: "," >
|   < PONTO: "." >
|   < ABRE_CHAVES: "{" >
|   < FECHA_CHAVES: "}" >
|   < ABRE_PARENTESIS: "(" >
|   < FECHA_PARENTESIS: ")" >
|   < ABRE_COLCHETES: "[" >
|   < FECHA_COLCHETES: "]" >
}

// Tabela de simbolos e tipos de dados
TOKEN:
{
  < INTEIRO: (<DIGITO>)+ >
| < REAL: (<DIGITO>)+ "." (<DIGITO>)+ >
| < IDENTIFICADOR: <LETRA> (<LETRA> | <DIGITO> | "_")* >
| < STRING: "\"" (~["\"","\n","\r"])* "\"" >
}

// Erros
TOKEN:
{
  < IDENTIFICADOR_INVALIDO: ((<LETRA>)+ ["@","#","$","&","?"] (<LETRA> | <DIGITO> | "_")*) | ((<DIGITO>)+ (<LETRA>)+ (<LETRA>|<DIGITO>)*)>
| < STRING_INVALIDA: "\"" (~["\"","\n","\r"])* ("\n"|"\r"|"\r\n") >
| < REAL_INVALIDO : (["+","-"])? (<DIGITO>)+ "." ~["0"-"9"] >
}

// Simbolos base
TOKEN:
{
  < #DIGITO : ["0"-"9"] >
| < #LETRA: ["a"-"z","A"-"Z"] >
}

// Qualquer outro erro
TOKEN:
{
    < SIMBOLO_INVALIDO: ~[] >
}

// Sintático


// 1. BIBLIOTECAS
void inicializar_programa():
{}
{
	( inclusao_biblioteca() )*
	( criar_funcoes() )*
  	<EOF> { System.out.println("Programa finalizado."); }
}

void inclusao_biblioteca():
{
	Token t;
}
{
    t = <TOKEN_IMPORT> { inserirTokenUnico(reservada, "IMPORT", t); }
    t = <STRING> { inserirTokenUnico(simbolo, "STRING", t); }
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t);
    					 System.out.println("Biblioteca importada"); }
}


// 2. BLOCO DE COMANDOS
void bloco_de_comandos():
{
}
{
  	( comando() )*
}


// Regra unica de comando.
void comando():
{
  	Token t;
}
{
	// 3. DECLARAÇÃO DE VARIÁVEIS
	declarar_variavel()
	// LOOKAHEAD para resolver a ambiguidade entre chamada de função e atribuição.
	| LOOKAHEAD(2) atribuicao()
	// 4. CHAMADA DE FUNÇÃO
	| chamar_funcao()
	// 5. ESTRUTURA CONDICIONAL (IF e IF/ELSE)
	| if_else()
	// 6. ESTRUTURA DE REPETIÇÃO (WHILE)
    | laco_while()
	// 7. ESTRUTURA DE REPETIÇÃO (FOR)
	| laco_for()
	// 8. COMANDO DE RETORNO
    | retorno()
	// 9. COMANDO DE ESCRITA
	| comando_escrita()
	// 10. COMANDO DE LEITURA
	| comando_leitura()
    | t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t); } // Permite comandos vazios
}


// Estrutura condicional if/else.
void if_else():
{
	Token t;
}
{
	t = <TOKEN_IF> { inserirTokenUnico(reservada, "IF", t); }
	t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } expressao()
	t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
	t = <ABRE_CHAVES> { inserirTokenUnico(reservada, "ABRE_CHAVES", t); } bloco_de_comandos()
	t = <FECHA_CHAVES> { inserirTokenUnico(reservada, "FECHA_CHAVES", t);
						System.out.println("If criado"); }
	( senao() )?
}

void senao():
{
	Token t;
}
{
  	t = <TOKEN_ELSE> { inserirTokenUnico(reservada, "ELSE", t); }
  	t = <ABRE_CHAVES> { inserirTokenUnico(reservada, "ABRE_CHAVES", t); } bloco_de_comandos()
  	t = <FECHA_CHAVES> { inserirTokenUnico(reservada, "FECHA_CHAVES", t);
  						System.out.println("Else criado"); }
}

// Laço de repetição while.
void laco_while():
{
	Token t;
}
{
    t = <TOKEN_WHILE> { inserirTokenUnico(reservada, "WHILE", t); }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } expressao()
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <ABRE_CHAVES> { inserirTokenUnico(reservada, "ABRE_CHAVES", t); } bloco_de_comandos()
    t = <FECHA_CHAVES> { inserirTokenUnico(reservada, "FECHA_CHAVES", t);
      					 System.out.println("While criado"); }
}

// Laço de repetição for.
void laco_for():
{
	Token t;
}
{
    t = <TOKEN_FOR> { inserirTokenUnico(reservada, "FOR", t); }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } ( atribuicao_simples() )?
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t); } ( expressao() )?
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t); } ( atribuicao_simples())?
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <ABRE_CHAVES> { inserirTokenUnico(reservada, "ABRE_CHAVES", t); } bloco_de_comandos()
    t = <FECHA_CHAVES> { inserirTokenUnico(reservada, "FECHA_CHAVES", t); }
}


// Comando de escrita de dados.
void comando_escrita():
{
	Token t;
}
{
    t = <TOKEN_WRITE> { inserirTokenUnico(reservada, "WRITE", t); }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } lista_de_argumentos()
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t); }
}


// Comando de leitura de dados.
void comando_leitura():
{
  	Token t;
}
{
    t = <TOKEN_READ> { inserirTokenUnico(reservada, "READ", t); }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); }
    t = <IDENTIFICADOR> { inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t); }
}

// Comando de retorno de função.
void retorno():
{
	Token t;
}
{
    t = <TOKEN_RETURN> {  inserirTokenUnico(reservada, "RETURN", t); } ( expressao() )?
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t);
    					  System.out.println("Retorno");}
}


// 11. ATRIBUIÇÕES
void atribuicao():
{
	Token t;
}
{
   	t = <IDENTIFICADOR> { inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
   	t = <ATRIBUICAO> { inserirTokenUnico(reservada, "ATRIBUICAO", t); } expressao()
   	t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t);
   						System.out.println("Atribuição"); }
}

// Regra auxiliar para o laço 'for', que é uma atribuição sem o ponto e vírgula final.
void atribuicao_simples():
{
	Token t;
}
{
    t = <IDENTIFICADOR> { inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    t = <ATRIBUICAO> { inserirTokenUnico(reservada, "ATRIBUICAO", t); } expressao()
}


// Nível mais alto da expressão. Começa com o operador de menor precedência (OR).
void expressao():
{}
{
	expressao_or()
}

// 12. OPERADORES LÓGICOS (OR)
void expressao_or():
{
	Token t;
}
{
    expressao_and() ( t = <OR> { inserirTokenUnico(reservada, "OR", t); } expressao_and() )*
}

// 13. OPERADORES LÓGICOS (AND)
void expressao_and():
{
	Token t;
}
{
    expressao_relacional() ( t = <AND> { inserirTokenUnico(reservada, "AND", t); } expressao_relacional() )*
}

// 14. OPERADORES RELACIONAIS (==, !=, <, >, <=, >=)
void expressao_relacional():
{
	Token t;
}
{
    expressao_aritmetica()
    (
        ( t = <IGUAL> { inserirTokenUnico(reservada, "IGUAL", t); }
        | t = <DIFERENTE> { inserirTokenUnico(reservada, "DIFERENTE", t); }
        | t = <MENOR> { inserirTokenUnico(reservada, "MENOR", t); }
        | t = <MAIOR> { inserirTokenUnico(reservada, "MAIOR", t); }
        | t = <MENOR_IGUAL> { inserirTokenUnico(reservada, "MENOR_IGUAL", t); }
        | t = <MAIOR_IGUAL> { inserirTokenUnico(reservada, "MAIOR_IGUAL", t); } )
        expressao_aritmetica()
    )?
}

// 15. OPERADORES ARITMÉTICOS (+, -)
void expressao_aritmetica():
{
	Token t;
}
{
	termo() ( ( t = <ADICAO> { inserirTokenUnico(reservada, "ADICAO", t); }
			  | t = <SUBTRACAO> { inserirTokenUnico(reservada, "SUBTRACAO", t); } ) termo() )*
}


// 16. OPERADORES ARITMÉTICOS (*, /)
void termo():
{
	Token t;
}
{
	fator() ( ( t = <MULTIPLICACAO> { inserirTokenUnico(reservada, "MULTIPLICACAO", t); }
			  | t = <DIVISAO> { inserirTokenUnico(reservada, "DIVISAO", t); } ) fator() )*
}

// 17. OPERADORES UNÁRIOS (!, -)
void fator():
{
	Token t;
}
{
    ( t = <SUBTRACAO> { inserirTokenUnico(reservada, "SUBTRACAO", t); }
    | t = <NOT> { inserirTokenUnico(reservada, "NOT", t); } ) fator()
|   valor_base()
}


// Base da recursão das expressões. Define os elementos atômicos.
void valor_base():
{
	Token t;
}
{
	t = <INTEIRO> { inserirTokenUnico(simbolo, "INTEIRO", t); }
|   t = <REAL> { inserirTokenUnico(simbolo, "REAL", t); }
// 18. USO DE STRINGS
|   t = <STRING> { inserirTokenUnico(simbolo, "STRING", t); }
|   t = <TOKEN_TRUE> { inserirTokenUnico(reservada, "TRUE", t); }
|   t = <TOKEN_FALSE> { inserirTokenUnico(reservada, "FALSE", t); }
|   t = <IDENTIFICADOR> { inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
// 19. USO DE PARÊNTESES
|	t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } expressao()
	t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
}

// Função para declarar variáveis
void declarar_variavel():
{
    Token t;
}
{
    ( t = <TOKEN_INT> { inserirTokenUnico(reservada, "INTEGER", t); }
    | t = <TOKEN_FLOAT> { inserirTokenUnico(reservada, "FLOAT", t); }
    | t = <TOKEN_CHAR> { inserirTokenUnico(reservada, "CHAR", t); }
    | t = <TOKEN_BOOL> { inserirTokenUnico(reservada, "BOOLEAN", t); }
    | t = <TOKEN_DOUBLE> { inserirTokenUnico(reservada, "DOUBLE", t); } )

    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){
        	System.out.println("IDENTIFICADOR_LONGO: "+ t.image);
       	}
        else{
        	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
        }
    }
    ( t = <VIRGULA> { inserirTokenUnico(reservada, "VIRGULA", t); } 

    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){
        	System.out.println("IDENTIFICADOR_LONGO: "+ t.image);
        }
        else{
        	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
        }
    })*
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t);
    					  System.out.println("Declarar variável");}
}

// Função para chamada de funções
void chamar_funcao():
{
    Token t;
}
{
    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){
        	System.out.println("IDENTIFICADOR_LONGO: "+ t.image);
        }
        else{
        	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
        }
    }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } ( lista_de_argumentos() )?
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <PONTO_VIRGULA> { inserirTokenUnico(reservada, "PONTO_VIRGULA", t);
    						System.out.println("Chamada de função"); }
}

// Regra auxiliar para lista de argumentos em chamadas de função
void lista_de_argumentos():
{
	Token t;
}
{
    expressao() (
    t = <VIRGULA> { inserirTokenUnico(reservada, "VIRGULA", t); } expressao() )*
}



// 20. DEFINIÇÃO DE FUNÇÕES
void criar_funcoes():
{
    Token t;
}
{
    ( <TOKEN_VOID>
    | <TOKEN_INT>
    | <TOKEN_FLOAT>
    | <TOKEN_CHAR>
    | <TOKEN_BOOL>
    | <TOKEN_DOUBLE> )
    
    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){
        	System.out.println("IDENTIFICADOR_LONGO: "+ t.image);
        }
        else{
        	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
        }
    }
    t = <ABRE_PARENTESIS> { inserirTokenUnico(reservada, "ABRE_PARENTESIS", t); } ( lista_de_parametros() )?
    t = <FECHA_PARENTESIS> { inserirTokenUnico(reservada, "FECHA_PARENTESIS", t); }
    t = <ABRE_CHAVES> { inserirTokenUnico(reservada, "ABRE_CHAVES", t); }
        bloco_de_comandos()
    t = <FECHA_CHAVES> { inserirTokenUnico(reservada, "FECHAS_CHAVES", t);
    					System.out.println("Função criada");}
}

// Regra auxiliar para lista de parâmetros em definições de função
void lista_de_parametros():
{
    Token t;
}
{
    ( t = <TOKEN_INT> { inserirTokenUnico(reservada, "INTEGER", t); }
    | t = <TOKEN_FLOAT> { inserirTokenUnico(reservada, "FLOAT", t); }
    | t = <TOKEN_CHAR> { inserirTokenUnico(reservada, "CHAR", t); }
    | t = <TOKEN_BOOL> { inserirTokenUnico(reservada, "BOOLEAN", t); }
    | t = <TOKEN_DOUBLE> { inserirTokenUnico(reservada, "DOUBLE", t); } )
    t = <IDENTIFICADOR> {
         if(t.image.length() > MAX){
         	System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image);
         }
         else{
         	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
         }
    }
    ( <VIRGULA> { inserirTokenUnico(reservada, "VIRGULA", t); } (
      <TOKEN_INT> { inserirTokenUnico(reservada, "INTEGER", t); }
    | <TOKEN_FLOAT> { inserirTokenUnico(reservada, "FLOAT", t); }
    | <TOKEN_CHAR> { inserirTokenUnico(reservada, "CHAR", t); }
    | <TOKEN_BOOL> { inserirTokenUnico(reservada, "BOOLEAN", t); }
    | <TOKEN_DOUBLE> { inserirTokenUnico(reservada, "DOUBLE", t); } )
        t = <IDENTIFICADOR> {
             if(t.image.length() > MAX){
             	System.out.println("IDENTIFICADOR_LONGO: "+ t.image);
             }
             else{
             	inserirTokenUnico(simbolo, "IDENTIFICADOR", t);
             }
        }
    )*
}