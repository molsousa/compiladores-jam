options
{
  static = false;
}

PARSER_BEGIN(Lexico)

import java.util.Scanner;
import java.util.LinkedList;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

class InfoToken {
    String tipo;
    String lexema;
    int linha;
    int coluna;

    public InfoToken(String tipo, String lexema, int linha, int coluna) {
        this.tipo = tipo;
        this.lexema = lexema;
        this.linha = linha;
        this.coluna = coluna;
    }

    @Override
    public String toString() {
        return String.format("Tipo: %s\nLexema: <'%s'>\nLinha: %d, Coluna: %d\n", this.tipo, this.lexema, this.linha, this.coluna);
    }
}

public class Lexico
{
    public static LinkedList<InfoToken> reservada = new LinkedList<>();
    public static LinkedList<InfoToken> simbolo = new LinkedList<>();
    private static final int MAX = 32;

    public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException {
        Lexico parser;
        FileInputStream arquivo;
        Scanner scanner = new Scanner(System.in);

        try {
            arquivo = new FileInputStream("fonte_1.txt");
        }
        catch(FileNotFoundException e) {
            System.out.println(e);
            return;
        }

        try {
            parser = new Lexico(arquivo);
            parser.inicializar_programa();
		}
		catch(ParseException e) {
            System.out.println("Erro de sintaxe: " + e.getMessage());
        }
        catch(TokenMgrError e) {
            System.out.println("Erro léxico: " + e.getMessage());
        }
        scanner.close();
    }

    public void inserirTokenUnico(LinkedList<InfoToken> l, String tipo, Token t) {
        for (InfoToken tok : l) {
            if (tok.lexema.equals(t.image)) {
                return;
            }
        }
        l.add(new InfoToken(tipo, t.image, t.beginLine, t.beginColumn));
    }

    public void imprimirTokens(LinkedList<InfoToken> l) {
        if (l.isEmpty()) {
            System.out.println("Lista vazia");
            return;
        }
        for (InfoToken tok : l) {
            System.out.println(tok);
        }
    }
}

PARSER_END(Lexico)

// TOKENS (Léxico)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// Palavras reservadas
TOKEN:
{
    < TOKEN_IF: "if" >
|   < TOKEN_ELSE: "else" >
|   < TOKEN_WHILE: "while" >
|   < TOKEN_FOR: "for" >
|   < TOKEN_VOID: "void" >
|   < TOKEN_INT: "integer" >
|   < TOKEN_FLOAT: "float" >
|   < TOKEN_CHAR: "character" >
|   < TOKEN_BOOL: "boolean" >
|   < TOKEN_RETURN: "return" >
|   < TOKEN_TRUE: "true" >
|   < TOKEN_FALSE: "false" >
|   < TOKEN_DOUBLE: "double" >
|   < TOKEN_SWITCH: "switch" >
|   < TOKEN_DO: "do" >
|   < TOKEN_TRY: "try" >
|   < TOKEN_EXCEPT: "except" >
|   < TOKEN_IMPORT: "import" >
| 	< TOKEN_READ: "read" >
| 	< TOKEN_WRITE: "write" >
}

// Operadores
TOKEN:
{
    < ADICAO : "+" >
|   < SUBTRACAO : "-" >
|   < MULTIPLICACAO : "*" >
|   < DIVISAO : "/" >
|   < ATRIBUICAO: "=" >
|   < MODULO: "%" >
|   < IGUAL: "==" >
|   < DIFERENTE: "!=" >
|   < MENOR: "<" >
|   < MAIOR: ">" >
|   < MAIOR_IGUAL: ">=" >
|   < MENOR_IGUAL: "<=" >
|   < AND: "&&" >
|   < NOT: "!" >
|   < OR: "||" >
|   < INCREMENTO: "++" >
|   < DECREMENTO: "--" >
|   < SOMA_ATRIBUICAO: "+=" >
|   < SUBTRACAO_ATRIBUICAO: "-=" >
|   < MULTIPLICACAO_ATRIBUICAO: "*=" >
|   < DIVISAO_ATRIBUICAO: "/=" >
|   < MODULO_ATRIBUICAO: "%/" >
}

// Simbolos reservados
TOKEN:
{
    < PONTO_VIRGULA: ";" >
|   < VIRGULA: "," >
|   < PONTO: "." >
|   < ABRE_CHAVES: "{" >
|   < FECHA_CHAVES: "}" >
|   < ABRE_PARENTESIS: "(" >
|   < FECHA_PARENTESIS: ")" >
|   < ABRE_COLCHETES: "[" >
|   < FECHA_COLCHETES: "]" >
}

// Tabela de simbolos e tipos de dados
TOKEN:
{
  < INTEIRO: (<DIGITO>)+ >
| < REAL: (<DIGITO>)+ "." (<DIGITO>)+ >
| < IDENTIFICADOR: <LETRA> (<LETRA> | <DIGITO> | "_")* >
| < STRING: "\"" (~["\"","\n","\r"])* "\"" >
}

// Erros
TOKEN:
{
  < IDENTIFICADOR_INVALIDO: ((<LETRA>)+ ["@","#","$","&","?"] (<LETRA> | <DIGITO> | "_")*) | ((<DIGITO>)+ (<LETRA>)+ (<LETRA>|<DIGITO>)*)>
| < STRING_INVALIDA: "\"" (~["\"","\n","\r"])* ("\n"|"\r"|"\r\n") >
| < REAL_INVALIDO : (["+","-"])? (<DIGITO>)+ "." ~["0"-"9"] >
}

// Simbolos base
TOKEN:
{
  < #DIGITO : ["0"-"9"] >
| < #LETRA: ["a"-"z","A"-"Z"] >
}

// Qualquer outro erro
TOKEN:
{
    < SIMBOLO_INVALIDO: ~[] >
}

// Sintático


// 1. BIBLIOTECAS
void inicializar_programa():
{}
{
	( inclusao_biblioteca() )*
	( criar_funcoes() )*
  	<EOF> { System.out.println("Análise sintática finalizada."); }
}

void inclusao_biblioteca():
{}
{
    <TOKEN_IMPORT> <STRING> <PONTO_VIRGULA>
}


// 2. BLOCO DE COMANDOS
void bloco_de_comandos():
{}
{
  	( comando() )*
}


// Regra unica de comando.
void comando():
{}
{
	  // 3. DECLARAÇÃO DE VARIÁVEIS
	  declarar_variavel()
	// LOOKAHEAD para resolver a ambiguidade entre chamada de função e atribuição.
	| LOOKAHEAD(2) atribuicao()
	// 4. CHAMADA DE FUNÇÃO
	| chamar_funcao()
	// 5. ESTRUTURA CONDICIONAL (IF e IF/ELSE)
	| if_else()
	// 6. ESTRUTURA DE REPETIÇÃO (WHILE)
    | laco_while()
	// 7. ESTRUTURA DE REPETIÇÃO (FOR)
	| laco_for()
	// 8. COMANDO DE RETORNO
    | retorno()
	// 9. COMANDO DE ESCRITA
	| comando_escrita()
	// 10. COMANDO DE LEITURA
	| comando_leitura()
    | <PONTO_VIRGULA> // Permite comandos vazios
}


// Estrutura condicional if/else.
void if_else():
{}
{
	<TOKEN_IF> <ABRE_PARENTESIS> expressao() <FECHA_PARENTESIS>
	<ABRE_CHAVES> bloco_de_comandos() <FECHA_CHAVES>
	( senao() )?
}

void senao():
{}
{
  	<TOKEN_ELSE> <ABRE_CHAVES> bloco_de_comandos() <FECHA_CHAVES>
}

// Laço de repetição while.
void laco_while():
{}
{
    <TOKEN_WHILE> <ABRE_PARENTESIS> expressao() <FECHA_PARENTESIS>
    <ABRE_CHAVES> bloco_de_comandos() <FECHA_CHAVES>
}

// Laço de repetição for.
void laco_for():
{}
{
    <TOKEN_FOR> <ABRE_PARENTESIS>
        ( atribuicao_simples() )? <PONTO_VIRGULA>
        ( expressao() )? <PONTO_VIRGULA>
        ( atribuicao_simples())?
    <FECHA_PARENTESIS>
    <ABRE_CHAVES> bloco_de_comandos() <FECHA_CHAVES>
}


// Comando de escrita de dados.
void comando_escrita():
{}
{
    <TOKEN_WRITE> <ABRE_PARENTESIS> lista_de_argumentos() <FECHA_PARENTESIS> <PONTO_VIRGULA>
}


// Comando de leitura de dados.
void comando_leitura():
{}
{
    <TOKEN_READ> <ABRE_PARENTESIS> <IDENTIFICADOR> <FECHA_PARENTESIS> <PONTO_VIRGULA>
}

// Comando de retorno de função.
void retorno():
{}
{
    <TOKEN_RETURN> ( expressao() )? <PONTO_VIRGULA> 
}


// 11. ATRIBUIÇÕES
void atribuicao():
{}
{
    <IDENTIFICADOR> <ATRIBUICAO> expressao() <PONTO_VIRGULA>
}

// Regra auxiliar para o laço 'for', que é uma atribuição sem o ponto e vírgula final.
void atribuicao_simples():
{}
{
    <IDENTIFICADOR> <ATRIBUICAO> expressao()
}


// Nível mais alto da expressão. Começa com o operador de menor precedência (OR).
void expressao():
{}
{
	expressao_or()
}

// 12. OPERADORES LÓGICOS (OR)
void expressao_or():
{}
{
    expressao_and() ( <OR> expressao_and() )*
}

// 13. OPERADORES LÓGICOS (AND)
void expressao_and():
{}
{
    expressao_relacional() ( <AND> expressao_relacional() )*
}

// 14. OPERADORES RELACIONAIS (==, !=, <, >, <=, >=)
void expressao_relacional():
{}
{
    expressao_aritmetica()
    (
        ( <IGUAL> | <DIFERENTE> | <MENOR> | <MAIOR> | <MENOR_IGUAL> | <MAIOR_IGUAL> )
        expressao_aritmetica()
    )?
}

// 15. OPERADORES ARITMÉTICOS (+, -)
void expressao_aritmetica():
{}
{
	termo() ( ( <ADICAO> | <SUBTRACAO> ) termo() )*
}


// 16. OPERADORES ARITMÉTICOS (*, /)
void termo():
{}
{
	fator() ( ( <MULTIPLICACAO> | <DIVISAO> ) fator() )*
}

// 17. OPERADORES UNÁRIOS (!, -)
void fator():
{}
{
    ( <SUBTRACAO> | <NOT> ) fator()
|   valor_base()
}


// Base da recursão das expressões. Define os elementos atômicos.
void valor_base():
{}
{
	<INTEIRO>
|   <REAL>
// 18. USO DE STRINGS
|   <STRING>
|   <TOKEN_TRUE>
|   <TOKEN_FALSE>
|   <IDENTIFICADOR>
// 19. USO DE PARÊNTESES
|	<ABRE_PARENTESIS> expressao() <FECHA_PARENTESIS>
}

// Função para declarar variáveis
void declarar_variavel():
{
    Token t;
}
{
    ( <TOKEN_INT> | <TOKEN_FLOAT> | <TOKEN_CHAR> | <TOKEN_BOOL> | <TOKEN_DOUBLE> )
    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image); }
        else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    }
    ( <VIRGULA> t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image); }
        else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    })*
    <PONTO_VIRGULA>
}

// Função para chamada de funções
void chamar_funcao():
{
    Token t;
}
{
    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image); }
        else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    }
    <ABRE_PARENTESIS> ( lista_de_argumentos() )? <FECHA_PARENTESIS> <PONTO_VIRGULA>
}

// Regra auxiliar para lista de argumentos em chamadas de função
void lista_de_argumentos():
{}
{
    expressao() ( <VIRGULA> expressao() )*
}



// 20. DEFINIÇÃO DE FUNÇÕES
void criar_funcoes():
{
    Token t;
}
{
    ( <TOKEN_VOID> | <TOKEN_INT> | <TOKEN_FLOAT> | <TOKEN_CHAR> | <TOKEN_BOOL> | <TOKEN_DOUBLE> )
    t = <IDENTIFICADOR> {
        if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image);}
        else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    }
    <ABRE_PARENTESIS> ( lista_de_parametros() )? <FECHA_PARENTESIS>
    <ABRE_CHAVES>
        bloco_de_comandos()
    <FECHA_CHAVES>
}

// Regra auxiliar para lista de parâmetros em definições de função
void lista_de_parametros():
{
    Token t;
}
{
    ( <TOKEN_INT> | <TOKEN_FLOAT> | <TOKEN_CHAR> | <TOKEN_BOOL> | <TOKEN_DOUBLE> )
    t = <IDENTIFICADOR> {
         if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image); }
         else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
    }
    ( <VIRGULA> ( <TOKEN_INT> | <TOKEN_FLOAT> | <TOKEN_CHAR> | <TOKEN_BOOL> | <TOKEN_DOUBLE> )
        t = <IDENTIFICADOR> {
             if(t.image.length() > MAX){ System.out.println("AVISO: IDENTIFICADOR_LONGO: "+ t.image); }
             else{ inserirTokenUnico(simbolo, "IDENTIFICADOR", t); }
        }
    )*
}